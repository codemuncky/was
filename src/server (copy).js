/* ======================================================================== *\
   Application server for node.js and PHP

   A small and fast event driven application engine for a standalone server
   utilizing PHP and websocket 

   Developed for the Raspbery PI linux platform.

   By Simon Rig√©t 2013 (c) MIT License 

todo:
  file upload temp file cleanup + php move tmp file accept (rename to php...)
  PHP headers not queit right.


\* ======================================================================== */

/* ======================================================================== *\
    Event handler

The event handler is a hub where event information are distributed to listeners.

Listners are informed about events by initiating a lasting SSE connection, 
with a 'watch list' request. When a state change occures on an item on the 
watch list, a tile rendering or a message are send.

The event handler will request state information on each new SSE request, 
throug the command handler. This i done by issuing a GET command to the interaction 
ofthe watch list.


  ** send message and let the JS call a re-rendering tile script? 

Events a generated by commands issued to the command handler. The command 
handler feeds the the event handler with eventsand store them in the eventlog.

  ** let event handler store events?

Later it might also include the command handler?
 
- Triggering action


\* ======================================================================== */

//----------------------------------------------------
// Debug functions
//----------------------------------------------------
var dump_depth=0;
function dump_obj(obj,max_depth) {
	var result='';
	var tab='';
	if(typeof(obj)!='object') return obj;
	if(!max_depth) max_depth=0;
	for(i=0;i<dump_depth;i++) tab+='--';
	for(var i in obj){
		// Mozilla bug when accessing document.domConfig
		if(i=='domConfig') continue;
		if(typeof(obj[i])=='object'){
			result+=tab+'['+i+']=>(object)('+dump_depth+','+max_depth+')\r\n';
			if(dump_depth<max_depth) {
				dump_depth++;
				result+=dump_obj(obj[i],max_depth);
				dump_depth--;
			}
		}else if(typeof(obj[i])=='function')
			result+=tab+'['+i+']=>(Function)\r\n';
		else if(typeof(obj[i])=='unknown')
			result+=tab+'['+i+']=>(unknown type)\r\n';
		else{
			str=''+obj[i];
			result+=tab+'['+i+']=>'+str.replace(/\</g,'&lt;')+"\r\n";
		}
	}
	return result;
}

var version='0.1.0';
var mumble=true;

/* ======================================================================== *\
   Load modules
\* ======================================================================== */
var http = require("http");
//var https = require('https');
var url = require("url");
var path = require("path");
var fs = require("fs");
var qs = require('querystring');

// External modules
var ini = require('ini');
var express = require('express');
//var formidable = require('formidable');
var WebSocketServer = require('ws').Server;

/* ======================================================================== *\
   Read configuration
\* ======================================================================== */
var config = ini.parse(fs.readFileSync('node-was.conf', 'utf-8'))
// Sainitize and validate
if(config.ip == undefined) config.ip='0.0.0.0';
if(config.port == undefined) config.port=8080;
if(config.maxReqBodySize == undefined) config.maxReqBodySize=1000;
if(config.docRoot == undefined) config.docRoot="public";
// Resolve path 
config.docRoot=path.normalize(config.docRoot);
if(config.docRoot.charAt(0) != '/') config.docRoot = __dirname + "/" + config.docRoot;
if(path.length == 1) {
  console.log("Can't serve files at: " + path);
  process.exit(1);
}

// console.log("Configuration:\n" + JSON.stringify(config,null,1));
console.log("========================================================================");
console.log("PHP-burner version: " + version);

// Catch errors
process.on('uncaughtExceptionX', function (err) {
    console.error('An uncaughtException:');
    console.error(err);
    // process.exit(1);
});


/* ======================================================================== *\
   Configure express 

   NB: The order of applying attributes will in some cases be reflected in 
   the order offits execution.
\* ======================================================================== */
var app = express();

app.disable('x-powered-by');
// By default, Express will use a generic HTML wrapper (a layout)
// to render all your pages. If you don't need that, turn it off.
// app.set('view options', {layout: false});

// Add support for GET, POST
app.use(express.json());
app.use(express.urlencoded());
// Enable file upload
// app.use(express.multipart()); 
// simulate DELETE and PUT with POST
app.use(express.methodOverride());

// Choose error handler
if(config.mode == 'debug')
  app.use(express.errorHandler({ dumpExceptions: true, showStack: true }));
else
  // Production 
  app.use(express.errorHandler());

/* ======================================================================== *\
   Set up routing serviceses (Middle ware)
\* ======================================================================== */
// Add websockets 
var server = http.createServer(app);
var wss = new WebSocketServer({server: server});
//var server = https.createServer(options, app);

// Middleware
app.use(app.router); 
// Check that file are on the allowed list
app.all(/./, function(request, response, next) {
  if(mumble) 
    console.log(request.client.remoteAddress 
      + " Request page: " + JSON.stringify(request.url) 
      + ((request.body != undefined && request.body.length>0) ? " With body ("+ request.body.length + ")":"")
    );
  // Allow all if undefined
  if(config.allowed != undefined
  && config.allowed[request._parsedUrl.pathname]== undefined){
    response.send(404);
    if(mumble) console.log(" Denied! Not on my list");
    return 0;
  }
  next('route');
})
 
// Catch root document
if(config.defaultRootDocument != undefined){
  app.all(/^\/$/, function(request, response, next) {
    request.url=config.defaultRootDocument;
    if(mumble) console.log(" Using root document default: " + config.defaultRootDocument);
    next('route');
  });
}

// Add PHP support
app.all(/\.php/, function(request, response, next) {
  // Check if resuested file exists
  fs.exists(config.docRoot + request._parsedUrl.pathname, function(exists){
    if (exists) {
      response.status(200);
      // Send response header

      // set content type text/html ?
      response.setHeader("Content-Type", "text/html");
      
      // Compose client information
      var info = {};
      info.header = request.headers;
      info.pathname = request._parsedUrl.pathname;
      info.query = request.query
      info.remoteaddress = request.client.remoteAddress;
      info.remoteport = request.client.remotePort;
      info.url=request.url;
      info.method=request.method;
      info.httpversion=request.httpVersion
      info.docroot=config.docRoot;

      info.body=request.body;
      info.files={};
      for(var f in request.files){
        info.files[f]={};
        info.files[f].name=request.files[f].name;
        info.files[f].size=request.files[f].size;
        info.files[f].tmp_name=request.files[f].path;
        info.files[f].type=request.files[f].type;
      }
      // console.log("Info :");
      // console.log(info);

      // Start PHP process
      var spawn = require("child_process").spawn;
      var arg=['php_burner.php'];
      php = spawn('php-cgi',['php_burner.php']);

      //Transfer header to php stdin
      php.stdin.write(JSON.stringify(info));
      php.stdin.end();

      // Catch output from PHP scrit and send it to client
      php.stdout.on('data', function (data) {
        // Add headers from PHP  
        if(!response.headersSent){
          // Assume PHP always send at least one header
          var header=true; 
          var line = data.toString().split("\r\n");
          for(var i in line){
            if(header){
              if(line[i].length >0){
                // Split header into name and value
                var split = line[i].indexOf(":");
                response.setHeader(line[i].substr(0,split),line[i].substr(split+2));
              }else if(i>0) 
                header=false;
            }else
              // End header and send body
              response.send(line[i]);
          }
        }else
          response.send(data);

      });

      // On the last output, end request
      php.stdout.on('end', function () {
        //console.log('PHP child process ended');
        response.end();
      });

      // Catch error output from PHP scrit and send it to client
      php.stderr.on('data', function (data) {
        response.send(data.toString());
      });
    } else {
      // File not found
      if(mumble) console.log("  I don't know that file");
      response.send(404);
    }
  });

})

// Apply static page server for the rest
app.use(express.static(config.docRoot));
app.use(express.favicon(config.docRoot + '/favicon.ico')); 
console.log("Serving static files at: " + config.docRoot);

/* ======================================================================== *\
   Start listening
\* ======================================================================== */
// Listen on PORT and call function on incomming requests
server.listen(config.port,config.ip);
console.log("Server listening at: " + config.ip + ":" + config.port );
console.log("========================================================================");


/*======================================================================== *\
  Websocket event handler

  client send a json request: 
    Usage: watch [id] | unwatch | exec [req] [id] | timer [id]

    watch:   event name to watch for   
    id:      A token returned with event or reply, typically an element id 
             to reveive the message. 
    unwatch: event name to delete from watch list. (No error given if it 
             does not exists)   
    exec:    script name. On error a message and an error message are returned.
             Output of the script are send to the client, with headers striped.
    query:   query json passed to the script.
    (engine: type of script Pt. only PHP support)

    timer:   event requests: at every on in  persistant (save to file)
      
\*======================================================================== */
// Define event handler
var eventHandler = {};
eventHandler.watch={};       // List of event names and who to tell

// Receive connections
wss.on('connection', function(socket) {
  // Register time
  socket.opened = new Date().getTime();
  // Trigger event

  // Set up incomming message handler
  socket.on('message', function(request) {
    if(mumble) console.log('Websocket received: %s', request);
    try{
      // Handle some defined functions
      var req=JSON.parse(request);

      // Add to watch list
      if(!!req.watch){ 
         // Special treatment of the chat watch
        if(req.watch=='chat'){
          // Send a frendly message
          var msg = {};
          msg.id=req.id;
          msg.origin="Server";
          msg.message = "Hello. your ID is #"+socket._socket._handle.fd +" on my list.\n";
          msg.message+="There are " + wss.clients.length + " clients on my list:\n"
          // List clients already on-line
          for(i in wss.clients)
            msg.message+= "User #" + wss.clients[i]._socket._handle.fd + "\n";
          if(socket.readyState==socket.OPEN) socket.send(JSON.stringify(msg));
          // Tell others that a client joined
          eventHandler.event({name:"chat",origin:"Server",message: 
            "User #" + socket._socket._handle.fd + " joined the chat room"} );
        }else{
          req.name="watch";
          req.origin=socket._socket._handle.fd;
          eventHandler.event(req);
        }
        eventHandler.addWatch(socket,req.watch,req.id);

      // Remove watch
      }else if(!!req.unwatch){ 
        eventHandler.removeWatch(socket,req.watch,req.id,socket);
        req.name="unwatch";
        req.origin=socket._socket._handle.fd;
        eventHandler.event(req);

      // Execute script
      }else if(!!req.exec){
        eventHandler.scriptExec(req,socket);
        req.name="command";
        req.origin=socket._socket._handle.fd;
        eventHandler.event(req);

      // Emit event
      }else if(!!req.event){
        eventHandler.event(req,socket);

      // timer function
      }else if(!!req.timer){
        eventHandler.setTimer(req,socket);
        req.name="timer";
        req.origin=socket._socket._handle.fd;
        eventHandler.event(req);

      // Chat
      }else if(!!req.chat){
        req.name="chat";
        req.origin="User #" + socket._socket._handle.fd;
        delete req.chat;
        eventHandler.event(req);

      // Server information 
      }else if(!!req.internal){
        req.name="internal";
        req.origin=socket._socket._handle.fd;
        eventHandler.event(req);
        if(socket.readyState==socket.OPEN) 
          socket.send(JSON.stringify(eventHandler.getStatus(req,socket)));          
       
      // Undefined function    
      }else{
        console.log('Undefined function');

      }
    }catch(e){
      console.log('Websocket parse Error: %s', e);
    }
  });
                      
  // Handle disconnections
  socket.on('close', function() {
    eventHandler.removeWatch(this);
  });

  socket.onerror= function(error){
    console.log('Socket error: %s', error);
  };
});

wss.on('error', function(error) {
  console.log("Websocket error: " + error);
});

// Add watch for event
eventHandler.addWatch=function(socket,name,id){
  if(this.watch[name]=== undefined) this.watch[name] =[];  
  this.watch[name].push({"socket":socket,"id":id});              
}

// Remove a watch go all watches for a socket
eventHandler.removeWatch=function(socket,name,id){
  // Delete one instance
  if(!!name){
    for(var i in this.watch[name])
      if(this.watch[name][i].socket==socket && ( !id || this.watch[name][i].id==id))
        delete this.watch[name][i];

  // Delete all instances to a socket
  }else{
    for(var i in this.watch)
      for(var ii in this.watch[i])
        if(this.watch[i][ii].socket==socket)
          delete this.watch[i][ii];
  }
}

eventHandler.emitEvent=function(req,socket){};

eventHandler.event=function(event){
  // Tell listners
  for (var name in eventHandler.watch) {
    // Send event update to socket    
    if(name==event.name || name=='all'){
      for(var i in eventHandler.watch[name] ){
        if(eventHandler.watch[name][i].socket.readyState==1){
          event.id=eventHandler.watch[name][i].id;
          eventHandler.watch[name][i].socket.send(JSON.stringify(event));
//  console.log({"Send event to":eventHandler.watch[name][i].socket._socket._handle.fd });
        }
      }
    }
    // Activate triggers
  }    
}

// Start a clock that sendt the time every second
eventHandler.clock = setInterval(function() {
	var t = Date().toString();
  var msg = {"name":"time"};
  msg.origin="Server";
  msg.message = t.substr(16,8);
  eventHandler.event(msg);
}, 1000);

eventHandler.setTimer=function(req,socket){};

// Execute script to handle request
eventHandler.scriptExec = function(req,socket){

  // Compose request information
  var info = {};
  info.pathname = req.exec;
  info.wsquery = req.req;
  info.remoteaddress = socket.remoteAddress;
  info.remoteport = socket.remotePort;
  info.url=socket.url;
  info.method='websocket';
  info.docroot=config.docRoot;
  info.header =socket.headers;
  info.httpversion=socket.httpVersion

  //console.log({"Info":info});

  // Start PHP process
  var spawn = require("child_process").spawn;
  var arg=['php_burner.php'];
  php = spawn('php-cgi',['php_burner.php']);

  //Transfer request to php stdin
  php.stdin.write(JSON.stringify(info));
  php.stdin.end();

  var res={};
  req.header=true; 

  // Catch output from PHP scrit 
  php.stdout.on('data', function (data) {
    //  console.log(data.toString());
    // Assume PHP always send at least one header: header ends with empty line
    if(req.header){
      var line = data.toString().split("\r\n\r\n");
      if(line.length>1){
        req.header=false;
        res.html=line[1];
      }
    }else
       res.html += data.toString();
  });

  // Catch error output from PHP scrit and send it to client
  php.stderr.on('data', function (data) {
    res.html += data.toString();
  });

  // On the last output, end request
  php.stdout.on('end', function () {
    // Compose reply
    if(!!req.id) res.id=req.id;
    res.origin="Client";
    try{
      res.json=JSON.parse(html);
      res.html='';
    }catch (e){
    }
    if(socket.readyState==socket.OPEN) socket.send(JSON.stringify(res));          
    // console.log('PHP child process ended' + JSON.stringify(res));
  });
}

/* ======================================================================== *\
   command interpreter demo
\* ======================================================================== */
eventHandler.getStatus=function(req,socket){
  var msg={};  

  // Relay chat message
  if(req.id=='chat'){
    msg.message = req.message;

  // Toggle switch
  }else{
    if(req.internal=='on')
      msg.html='<div id="'+req.id+'" class="on" onclick="sw(this.id,\'off\');">ON</div>';
    else if(req.internal=='off')
      msg.html='<div id="'+req.id+'" class="off" onclick="sw(this.id,\'on\');">OFF</div>';
    else if(req.internal=='info'){
      msg.html='<div id="'+req.id+'">';
      msg.html +='<table class="_info"><tr><th colspan="2">PHP Application Server version: '
        + version +'</th></tr></table><br>';
      msg.html +='<table class="_info"><tr><th colspan="2">Memory usages</th></tr>'
        + '<tr><td>In RAM memory:</td><td>' + process.memoryUsage().rss +'</td></tr>'
        + '<tr><td>V8 Heap total:</td><td>' + process.memoryUsage().heapTotal +'</td></tr>'
        + '<tr><td>V8  Heap used:</td><td>' + process.memoryUsage().heapUsed +'</td></tr>'
        + '</table><br>';
      msg.html +='<table class="_info"><tr><th colspan="2">Privileges</th></tr>'
        + '<tr><td>User ID:</td><td>' +  process.getuid() + '</td></tr>'
        + '<tr><td>Group ID:</td><td>' + process.getgid() + '</td></tr>'
        + '<tr><td>File create mask:</td><td>' + ('000' + process.umask().toString(8)).substr(-3) + '</td></tr>'
        + '</table><br>';
      msg.html +='<table class="_info"><tr><th colspan="2">Modules versions</th></tr>';
      for (var i in process.versions) 
        msg.html += '<tr><td>' + i + '</td><td>' + process.versions[i] +'</td></tr>';
      msg.html += '</table><br>';
      msg.html +='<table class="_info"><tr><th colspan="2">Platform</th></tr>'
        + '<tr><td>architecture:</td><td>' +  process.arch + '</td></tr>'
        + '<tr><td>Operating system:</td><td>' + process.platform + '</td></tr>'
        + '<tr><td>Up time:</td><td>' + process.uptime() + '</td></tr>'
        + '</table><br>';

      msg.html +='<table class="_info"><tr><th colspan="2">Configuration</th></tr>'
      for (var i in config) {
        msg.html += '<tr><td>' + i + '</td><td>';
        if(config[i].constructor === Object || config[i].constructor === Array)
          msg.html += '<pre>' + JSON.stringify(config[i], null, 2) +'</pre></td></tr>';
        else
          msg.html += config[i] + '</td></tr>';
      }
      msg.html += '</table><br>';

      msg.html +='<table class="_info"><tr><th colspan="3">Websocket clients</th></tr>'
      for(i in wss.clients){
        msg.html += '<tr><td>fd #' + wss.clients[i]._socket._handle.fd;
        if(wss.clients[i]._socket._handle.fd == socket._socket._handle.fd)
          msg.html += ' *You* ';
        msg.html += '</td><td> IP:' + wss.clients[i]._socket.remoteAddress 
          + ":" +  + wss.clients[i]._socket.remotePort 
          + '</td><td>'+ (new Date().getTime() - wss.clients[i].opened) + '</td></tr>';
      }
      msg.html += '</table><br>';

      msg.html +='<table class="_info"><tr><th colspan="2">Watch list</th></tr>'
      for (var i in eventHandler.watch) {
        msg.html += '<tr><td>' + i + '</td><td>';
        for(var ii in eventHandler.watch[i]){
          msg.html += '#' + eventHandler.watch[i][ii].socket._socket._handle.fd 
            + ' -> '+ eventHandler.watch[i][ii].id + '<br>';
        }
        msg.html += '</td></tr>'
      }
      msg.html += '</table></div>';
    }


  }

  msg.id=req.id;
  return msg;
}


/*

  
  var msg={};

  do{
    // see if its an array
    try{  
      var req = JSON.parse(request);
    }catch(e){
      var req = request.split(' ');
    }

    // Lexing: make list of tokens
    // Parsing: Find one of each type:  action id [state]
    try{
      for(i in req){
        if(action.indexOf(req[i]>-1)) var action = req[i];
        else if(state.indexOf(req[i]>-1)) var state = req[i];
        else var id = req[i];
      }
    }catch(e){
      msg.error='I don\'t understand the word "'+req[i]+'" here.';
    }

    if(!msg.error) switch(action){
    case 'watch':
      // 
      break;  
    case 'start':
      break;  
    case 'end':
      break;  
    case 'get':
      break;  
    case 'set':
      if(state=='on')
        msg.html='<div id="'+id+'" class="off" onclick="wsend(\'set \' + this.id + \'on\');">OFF</div>';
      else
        msg.html='<div id="'+id+'" class="on" onclick="wsend(\'set \' + this.id + \'off\');">ON</div>';
      msg.id=id;
      break;  
    default:
      if(!action){
        msg.reply=request + ' to you too';
        msg.broadcast=true;
        msg.id='chat'
      }else
        msg.error='I don\'t know how to do that';
    }

  }while(false);

  if(msg.error) 
    msg.reply="Unable to comply";
  else if(!msg.reply)
    msg.reply='Ok';
  
  return msg;
}


var WebSocketServer = require('ws').Server
  , wss = new WebSocketServer({host:'0.0.0.0',port: 8082});

var chat = {
        clients: new Array(),
        
        run: function(){
                wss.on('connection', function(ws) {

                        ws.on('message', function(message) {
                                console.log('received: %s', message);
                                chat.dispatch(ws, message);
                        });
                        
                        ws.on('close', function() {
                                chat.removeClient(ws);
                                chat.updateUserListOnClients();
                        });
                });
        
        },
        
        removeClient: function(ws){
                for(i = 0; i < chat.clients.length; i++){
                        if(chat.clients[i].socket === ws){
                                chat.clients.splice(i,1);
                                console.log('remove client');
                        }
                }
        },
        
        registerClient: function(ws, client){
                var client = { socket : ws, name : client};
                chat.clients.push(client);
                chat.updateUserListOnClients();
        },
        
        broadcast: function(message, fromSocket){
                var user = chat.getClientName(fromSocket);
                chat.broadcastCommand(user+': '+message);
        },

        updateUserListOnClients: function(){
                var userList = new Array();
                for(i = 0; i < chat.clients.length; i++){
                        userList.push(chat.clients[i].name);
                }
                console.log(userList.concat());
                chat.broadcastCommand('/updateUserList '+userList.concat());
        },
        
        broadcastCommand: function(cmd){
                for(i = 0; i < chat.clients.length; i++){
                        try{                
                                chat.clients[i].socket.send(cmd);
                        } catch(error){
                                chat.clients.splice(i,1);
                                console.log(error);
                        }
                        
                }
        },
        
        getClientName: function(ws){
                for(i = 0; i < chat.clients.length; i++){
                        if(chat.clients[i].socket === ws){
                                return chat.clients[i].name;
                        }
                }
        },
        
        dispatch: function(ws, message){
        
                var cmd = '';
                var param = '';

                if(message.indexOf('/') === 0){
                        cmd = message.split(' ')[0];
                        param = message.replace(cmd, '');

                }

                switch(cmd){
                        case '/broadcast':
                                chat.broadcast(param, ws);
                                break;
                        case '/connect':
                                var msg = param.replace(' ','').replace(/(<([^>]+)>)/ig,"");
                                if(msg != ''){
                                        chat.registerClient(ws, msg);
                                }
                                break;
                }
                
        }

}

chat.run();




*/

